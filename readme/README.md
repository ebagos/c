# 説明

一昨年に行ったC++学習からの問題<br>
基本的にProject Eulerの最初のほうから引っ張ってきた（2番めの問題を除く）ため、
番号が飛んでいる

# 進め方

- GitLab（GitHubのようなもの）とMattermost（Slackのようなもの）を使い、問題は各人個別に進めてもらう
- 参加者が希望した場合は、会議室等を使用して個別・集合で説明する
- 省メモリ、エラー対策、わかりやすいソースコードであることに重点をおく

以下、各問題の説明の一覧

---------------

---------------



# 01汎用化とは

## 問題
1以上1000未満の整数で、3または5で割り切れるものの和を求める<br>
複数の解決法を提示し、どの解法を選ぶべきか評価せよ（コメントとしてソースコード内に記入せよ）

## ねらい
１つの問題を解くために色々考えなければならないことを身につけてもらう

    - 動作確認をどうとらえるか
    - 「汎用的に使える」というのはどういうことか

など

---------------

# 02メッセージの多言語対応

## 問題

以下の4言語、4つの挨拶を対話的に表示するプログラムを作成せよ

| 　　 |  日本語   |     英語      | フランス語  |    ドイツ語      |
|:---:|:--------:|:------------: |:---------:|:--------------:|
| 朝　 | おはよう　 | Good moring  |  Bonjour  |  Guten Morgen   |
| 昼　 | こんにちは |    Hello     |  Bonjour  |    Guten Tag    |
| 夜　 | こんばんは | Good evening |  Bonsoir  |   Guten Abend   |
| 別れ | さようなら |   Good-by    | Au revoir | Auf Wiedersehen |

プログラムは、
1. 最初の入力で言語選択
1. 次の選択でシチュエーション選択
1. 最初に戻る、または終了

- ユーザインタフェースはご自由に！
- 拡張性を考慮すること

## ねらい
ポインタの操作の基本をおさえる。

---------------

# 03変数のビット幅

## 問題
13195 の素因数は 5, 7, 13, 29 である<br>
600851475143 の素因数のうち最大のものを求めよ

## ねらい
単純にロジックを考える問題<br>
変数のビット幅の決め方

---------------

# 04ロジックの工夫

## 問題
左右どちらから読んでも同じ値になる数を回文数という.<br>
2桁の数の積で表される回文数のうち, 最大のものは 9009 = 91 × 99 である.<br>
では, 3桁の数の積で表される回文数の最大値を求めよ.<br>

## ねらい
C++や他の言語では文字列を使用するという手もあるが、Cではそれは手間がかかりすぎる<br>
本問題は、
- 回文数をどうやって見つけるか
- また処理をいかに速くするか

を考えるものである（まぁ、簡単なんですけどね）

---------------

# 05ロジックの工夫

## 問題
2520 は 1 から 10 の数字の全ての整数で割り切れる数字であり, そのような数字の中では最小の値である.<br>
では, 1 から 20 までの整数全てで割り切れる数字の中で最小の正の数はいくらになるか.

## ねらい
ユークリッドの互除法さえ知っていれば（あるいはネットで検索すれば）、ロジックは難しくない<br>
パラメータや変数をどう定義するか、チェックするかが重要であることを示す

---------------

# 06overflow/underflow

## 問題
最初の10個の自然数について, その二乗の和は,<br>
1^2 + 2^2 + ... + 10^2 = 385

最初の10個の自然数について, その和の二乗は,<br>
(1 + 2 + ... + 10)^2 = 3025

これらの数の差は 3025 - 385 = 2640 となる.<br>

同様にして, 最初の100個の自然数について二乗の和と和の二乗の差を求めよ.<br>

## ねらい
C/C++では加算、減算でのoverflow/underflowは無視されるのでプログラムが対応しなければならい<br>
その必要性がない本問題で、その必要性を考える<br>
※一つ前の数値を覚えておいてそれより小さくなるか、大きくなるかで簡単にチェックはできる
※しかしそれは事後に発覚するパターン
※最適は予め安全な上限値を決めておくことではないか！？

---------------

# 07変数の割当

## 問題
正の整数に以下の式で繰り返し生成する数列を定義する.

-    n → n/2 (n が偶数)
-    n → 3n + 1 (n が奇数)

13からはじめるとこの数列は以下のようになる.<br>
13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1<br>

13から1まで10個の項になる. <br>
この数列はどのような数字からはじめても最終的には 1 になると考えられているが, まだそのことは証明されていない(コラッツ問題)<br>

さて, 100万未満の数字の中でどの数字からはじめれば最長の数列を生成するか.<br>

注意: 数列の途中で100万以上になってもよい<br>

## ねらい
変数の型をどう定めるか、を考えてもらう。<br>
参考ソースコードは、扱う数値をuintmax_tとした。<br>
これは処理系で扱える最大幅であり、すなわちそれだけメモリ（スタック）を多く消費することになる。<br>
また、伝統的にC言語ではデフォルトでintを使用することが多いが、そういう伝統でいいのかを考えてもらう。<br>

---------------

# 08解答不能

## 問題
n × (n - 1) × ... × 3 × 2 × 1 を n! と表す.<br>

例えば, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800 となる.<br>
この数の各桁の合計は 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27 である.<br>

では, 100! の各桁の数字の和を求めよ.<br>

## ねらい
オーバーフローしてしまう問題。<br>
現仕様のC言語では何らかの特殊な拡張がない限り解は出せないはず。<br>
- オーバフローすることに気づくか否か？

---------------

# 09メモリ操作

## 問題
5000個以上の名前が書かれている46Kのテキストファイル names.txt を用いる. まずアルファベット順にソートせよ.<br>

のち, 各名前についてアルファベットに値を割り振り, リスト中の出現順の数と掛け合わせることで, 名前のスコアを計算する.<br>

たとえば, リストがアルファベット順にソートされているとすると, COLINはリストの938番目にある. またCOLINは 3 + 15 + 12 + 9 + 14 = 53 という値を持つ. よってCOLINは 938 × 53 = 49714 というスコアを持つ.<br>

ファイル中の全名前のスコアの合計を求めよ.<br>

## ねらい
ファイルI/Oはできればいい（エラー処理を考慮していることが重要）<br>
大きなデータ＝メモリを効率よく扱う問題<br>
ポインタに苦しんでもらいたが、この程度では大したことないか？<br>

---------------

# 10追加問題

## 問題
順列とはモノの順番付きの並びのことである. たとえば, 3124は数 1, 2, 3, 4 の一つの順列である. すべての順列を数の大小でまたは辞書式に並べたものを辞書順と呼ぶ. 0と1と2の順列を辞書順に並べると<bbr>
012 021 102 120 201 210<br>
になる.<br>

0,1,2,3,4,5,6,7,8,9からなる順列を辞書式に並べたときの100万番目はいくつか?<br>

## ねらい
C++学習のときに物足りない人向けに用意した問題。<br>
記憶ではここまで至らなかった。

---------------

# 11追加問題

## 問題
順列とはモノの順番付きの並びのことである. たとえば, 3124は数 1, 2, 3, 4 の一つの順列である. すべての順列を数の大小でまたは辞書式に並べたものを辞書順と呼ぶ. 0と1と2の順列を辞書順に並べると<bbr>
012 021 102 120 201 210<br>
になる.<br>

0,1,2,3,4,5,6,7,8,9からなる順列を辞書式に並べたときの100万番目はいくつか?<br>

## ねらい
C++学習のときに物足りない人向けに用意した問題。<br>
記憶ではここまで至らなかった。
